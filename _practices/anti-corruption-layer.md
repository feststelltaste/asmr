---
title: "Anti-Corruption Layer"
stage: apply
category: Legacy Modernization
description: "Providing a dedicated translation boundary between a legacy system and new code to prevent outdated data structures and naming from polluting a modern domain model."
strategic_value: supporting
evolution: commodity
devops_phases: [plan, code]
---

## Problem

How do you write clean, maintainable new code — particularly when generated by AI agents — against a legacy system whose data model, naming, and domain concepts are inconsistent, outdated, or shaped by database constraints rather than business reality?

*This problem is difficult because:*

- Legacy systems accumulate decades of implicit, inconsistent domain concepts where naming is arbitrary and models are shaped by historical database constraints, not business logic.
- Directly coupling new code to legacy DTOs or schemas causes those concepts to bleed into the new codebase, spreading the "corruption" incrementally.
- You often cannot change the legacy system: it may be a vendor product, a third-party API, or too risky to touch during an active modernization.
- AI agents generating new code against a legacy API will reproduce the legacy's naming and concepts in their output unless given a clean, explicit target model to work with.

*Yet, solving this problem is feasible because:*

- The integration boundary between legacy and new systems is typically well-defined: an API surface, a database schema, or a message format.
- A translation layer at that boundary converts legacy representations to clean domain objects without either side needing to change.
- AI agents and LLMs are highly effective at generating the adapter, mapper, and gateway code that makes up an ACL — once the target model is defined, the mechanical translation is a task agents perform reliably.

## Solution

Implement a translation layer — the Anti-Corruption Layer — at every boundary where new or agent-generated code touches the legacy system:

1. **Map the boundary** — identify every point where new code must interact with the legacy system (API calls, DB queries, message consumption). Agentic tools can enumerate these call sites across a large codebase quickly.
2. **Define the target domain model** — model the concepts in your new system using clean, domain-driven naming and structures, independent of legacy constraints. This target model acts as the "contract" for both human and AI-generated code.
3. **Generate adapters at the boundary** — translate legacy representations to clean domain types for inbound data, and vice versa for outbound writes. Point agents at the legacy schema and your target model and have them generate the necessary adapter and mapper classes.
4. **Isolate the translation logic** — ensure ACL code resides only at the boundary. If legacy concepts appear in your core domain logic, the layer has been breached — enforce this with explicit code review and architectural fitness functions.

**Implementation patterns within the ACL:**

- **Adapter** — converts legacy DTOs to domain objects at the boundary.
- **Repository** — hides legacy database access behind a clean, domain-oriented interface.
- **Gateway** — wraps legacy API calls in a typed, domain-friendly client.
- **Semantic Wrapper** — wraps the old software to emulate new abstractions, even when the underlying implementation has not yet changed.

## Tradeoffs

**Pros:**

- New and agent-generated code remains clean and free from legacy naming constraints.
- The legacy system and new system can evolve independently.
- Core domain logic becomes easier to test in isolation — and easier for AI agents to reason about and modify correctly.

**Cons:**

- The ACL introduces an additional layer to maintain.
- If the legacy schema changes frequently, the ACL becomes a significant ongoing cost.
- Teams may underestimate translation complexity until they encounter subtle legacy edge cases.

**Difficulties:**

- Identifying precise boundaries in a tightly coupled legacy system — especially if agents have already begun generating code that mixes legacy and domain concepts.
- Preventing ACL concepts from drifting into the domain over time requires consistent architectural discipline and fitness functions.

## Rationale

When AI agents generate new code against a legacy system without an ACL, they will inevitably reproduce the legacy's naming, structures, and implicit assumptions — because those are the patterns present in the codebase context they receive. An ACL makes the target model explicit and gives agents a clean contract to code against. This is not just good DDD practice; it is a prerequisite for AI-assisted modernization that does not replicate legacy debt into new code.

## Known Uses

- [Hschwentner.io — Domain-Driven Refactorings](https://hschwentner.io/domain-driven-refactorings/) — catalogues ACL-based refactoring moves applied in real legacy codebases, with concrete before/after examples of wrapping legacy models behind clean domain interfaces.

## References

- [OORP — "Present the Right Interface"](https://oorp.github.io/#present-the-right-interface) — the object-oriented reengineering pattern that formalises wrapping a legacy component behind a clean abstraction; the direct structural ancestor of the ACL.
- [Eric Evans — Domain-Driven Design (Blue Book)](https://www.domainlanguage.com/ddd/) — original formalization of the ACL as a strategic context mapping pattern; chapters on context maps and integration define the vocabulary.
- [Vaughn Vernon — Implementing Domain-Driven Design](https://www.oreilly.com/library/view/implementing-domain-driven-design/9780133039900/) — practical ACL implementation guidance covering adapters, gateways, and testing strategies in real systems.

## Related Patterns

- [Strangler Fig Pattern](../strangler-fig-pattern/) — the ACL is a prerequisite; once it is in place, you can strangle the legacy system slice by slice without new code absorbing legacy concepts.
- **Shared Database** — an anti-pattern the ACL helps avoid; direct shared DB access bypasses the translation boundary and lets legacy schema bleed into new services.
- [Agentic Coding Workflows](../agentic-coding-workflows/) — agents generating new services against a legacy system should be given the ACL interface as their target contract, not the raw legacy schema.

## What Next

With an ACL in place at a legacy boundary, use [Strangler Fig Pattern](../strangler-fig-pattern/) to begin routing functionality to the new system — the ACL provides the translation infrastructure you need to migrate incrementally without a flag day.

## Staging History

**Apply (Feb 2026):** The Anti-Corruption Layer is a foundational, well-proven practice for any serious modernization effort. It is a standard prerequisite for protecting new domain models from legacy data pollution and has become even more critical when using agents to generate new services.
